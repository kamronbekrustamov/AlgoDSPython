### **Problem 1.4: Palindrome Permutation**

**Problem Statement:** Given a string, write a function to check if it is a permutation of a palindrome. A palindrome is a word or phrase that is the same forwards and backwards. A permutation is a rearrangement of letters. The palindrome does not need to be limited to just dictionary words.

**EXAMPLE**
`Input: "Tact Coa"`
`Output: True (permutations: "taco cat", "atco cta", etc.)`

---

### **Explanation: The Core Insight**

Before jumping into code, the book emphasizes understanding the fundamental properties of a palindrome.

*   A palindrome reads the same forwards and backward, meaning characters are mirrored around the center.
*   Consider an **even-length** palindrome like `"level"`. Every character has a matching pair. All character counts are **even**.
*   Consider an **odd-length** palindrome like `"racecar"`. All characters *except one* have a matching pair. There are two 'r's, two 'a's, two 'c's, and one 'e' in the middle. All character counts are **even**, except for one, which is **odd**.

This leads to the crucial rule that the solution is based on:

> A string can be a permutation of a palindrome **if and only if at most one character has an odd count.**

If more than one character has an odd count, it's impossible to arrange them into a mirrored palindrome structure. Our goal, therefore, is to count the occurrences of each character and verify this rule.

We also need to handle the book's implicit rules:
*   **Case Insensitivity:** "Tact Coa" is treated the same as "tactcoa".
*   **Ignore Spaces:** The spaces in "Tact Coa" are ignored.

---

### **Solution 1: Using a Hash Map (Frequency Table)**

This is the most direct and intuitive approach presented in the book. We use a hash map (or an array if the character set is small) to store the frequency of each character.

#### **Algorithm**
1.  Create a hash map to store character counts.
2.  Iterate through the input string, character by character.
3.  For each character:
    *   If it's not a letter, ignore it.
    *   Convert it to lowercase.
    *   Increment its count in the hash map.
4.  After counting all characters, iterate through the values (the counts) in the hash map.
5.  Keep a counter for how many characters have an odd count.
6.  If this counter ever exceeds 1, you know it's not a palindrome permutation, so return `false`.
7.  If the loop finishes without the counter exceeding 1, return `true`.

#### **Code Implementation (Java)**

```java
import java.util.HashMap;
import java.util.Map;

public class Solution {

    /**
     * Checks if a string is a permutation of a palindrome using a hash map.
     * This is the primary solution presented in the book.
     */
    public static boolean isPermutationOfPalindrome(String phrase) {
        // Create a frequency table (hash map)
        Map<Character, Integer> charCounts = new HashMap<>();

        // Count the number of each character
        for (char c : phrase.toCharArray()) {
            // Ignore non-alphabetic characters and handle case
            if (Character.isLetter(c)) {
                c = Character.toLowerCase(c);
                charCounts.put(c, charCounts.getOrDefault(c, 0) + 1);
            }
        }

        // Check for the number of odd counts
        int oddCount = 0;
        for (int count : charCounts.values()) {
            if (count % 2 != 0) {
                oddCount++;
            }
            // Optimization: we can stop early if we find more than one
            if (oddCount > 1) {
                return false;
            }
        }

        // If we finish the loop, it's a valid permutation
        return true;
    }

    public static void main(String[] args) {
        System.out.println("'Tact Coa' -> " + isPermutationOfPalindrome("Tact Coa")); // true
        System.out.println("'racecar' -> " + isPermutationOfPalindrome("racecar")); // true
        System.out.println("'abc' -> " + isPermutationOfPalindrome("abc")); // false
        System.out.println("'' -> " + isPermutationOfPalindrome("")); // true (empty string is a palindrome)
    }
}
```

#### **Complexity Analysis**
*   **Time Complexity: O(N)**, where N is the length of the string. We iterate through the string once to build the map and once (over the unique characters) to check the counts.
*   **Space Complexity: O(K)**, where K is the number of unique characters in the string. In the worst case, K can be up to N.

---

### **Solution 2: Using a Bit Vector (Optimized)**

The book presents this as a clever, space-optimized solution that is a great talking point in an interview. It leverages the fact that we only care about the *parity* (even or odd) of a character's count, not the count itself.

#### **Algorithm**
1.  We use a single integer, let's call it `bitVector`, initialized to 0. Each bit in this integer will represent a character (e.g., bit 0 for 'a', bit 1 for 'b', etc.).
2.  Iterate through the input string.
3.  For each character (after cleaning it):
    *   Calculate its position in the alphabet (e.g., 'a' -> 0, 'b' -> 1).
    *   Create a "mask" by shifting the number 1 left by that position.
    *   **Toggle** the corresponding bit in our `bit_vector`. We do this using the XOR (`^`) operator.
        *   If the bit was 0 (even count so far), it becomes 1 (odd count).
        *   If the bit was 1 (odd count so far), it becomes 0 (even count).
4.  After iterating, the `bit_vector` will have a `1` in every position corresponding to a character that appeared an odd number of times.
5.  We just need to check if this `bit_vector` has at most one bit set to `1`. A neat trick for this is: `n & (n - 1)`. This operation clears the least significant '1' bit of a number `n`. So, our final check is `bit_vector == 0 or (bit_vector & (bit_vector - 1)) == 0`.

#### **Code Implementation (Java)**

```java
public class OptimizedSolution {

    /**
     * Checks if a string is a permutation of a palindrome using a bit vector.
     * Assumes a character set of ASCII a-z for simplicity, as in the book's example.
     */
    public static boolean isPermutationOfPalindrome(String phrase) {
        int bitVector = 0;
        int charIndex;

        for (char c : phrase.toCharArray()) {
            if (Character.isLetter(c)) {
                c = Character.toLowerCase(c);
                // Map character to a bit position (0-25 for a-z)
                charIndex = c - 'a';
                int mask = 1 << charIndex;
                // Toggle the bit
                bitVector ^= mask;
            }
        }

        // Check if at most one bit is set to 1.
        // A number is a power of two (or zero) if n & (n-1) is 0.
        // This is true for 0 (0000) and numbers like 1000, 0010, etc.
        return bitVector == 0 || (bitVector & (bitVector - 1)) == 0;
    }

    public static void main(String[] args) {
        System.out.println("'Tact Coa' -> " + isPermutationOfPalindrome("Tact Coa")); // true
        System.out.println("'racecar' -> " + isPermutationOfPalindrome("racecar")); // true
        System.out.println("'abc' -> " + isPermutationOfPalindrome("abc")); // false
    }
}
```

#### **Complexity Analysis**
*   **Time Complexity: O(N)**, where N is the length of the string. We only iterate through the string once.
*   **Space Complexity: O(1)**. This is the key advantage. The `bit_vector` is a single integer, whose size is constant regardless of the input string's length.

The book recommends being able to discuss both solutions, starting with the more intuitive hash map and then offering the bit vector as a clever optimization.