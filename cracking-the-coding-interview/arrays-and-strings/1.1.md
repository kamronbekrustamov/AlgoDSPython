### **Problem 1.1: Is Unique**

**Problem Statement:** Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?

**EXAMPLE**
`Input: "abcdef"`
`Output: True`

`Input: "hello"`
`Output: False`

---

### **Explanation: The Core Approaches**

The book explains that this problem can be solved in several ways, each with different trade-offs between time complexity and space complexity. The key is to understand these trade-offs and how the constraint "cannot use additional data structures" forces a change in approach.

---

### **Solution 1: Using a Hash Set (or an Array)**

This is the most straightforward and efficient solution in terms of time complexity. The idea is to iterate through the string and keep track of the characters you have already seen.

#### **Algorithm**
1.  Create a data structure to store seen characters (a `HashSet` is ideal).
2.  Iterate through the string, character by character.
3.  For each character, check if it is already in the set.
    *   If it is, you've found a duplicate. Return `false`.
    *   If it isn't, add it to the set.
4.  If the loop finishes without finding any duplicates, return `true`.

#### **Code Implementation (Java)**

```java
import java.util.HashSet;
import java.util.Set;

public class Solution {

    /**
     * Checks if a string has all unique characters using a hash set.
     * This is the most common and time-efficient solution.
     */
    public static boolean isUnique(String str) {
        // If the string is longer than the number of possible unique characters
        // (assuming ASCII), it must contain duplicates.
        if (str.length() > 128) {
            return false;
        }

        Set<Character> seen = new HashSet<>();
        for (char c : str.toCharArray()) {
            if (seen.contains(c)) {
                return false; // Duplicate found
            }
            seen.add(c);
        }
        return true; // No duplicates found
    }

    public static void main(String[] args) {
        System.out.println("'abcdef' -> " + isUnique("abcdef")); // true
        System.out.println("'hello' -> " + isUnique("hello"));   // false
        System.out.println("'' -> " + isUnique(""));             // true
    }
}
```

#### **Complexity Analysis**
*   **Time Complexity: O(N)**, where N is the length of the string. We iterate through the string once, and hash set operations (add, contains) take O(1) time on average.
*   **Space Complexity: O(min(N, C))**, where C is the size of the character set (e.g., 128 for ASCII). In the worst case, we store every character from the string in the set.

---

### **Solution 2: Without Additional Data Structures**

This directly addresses the follow-up question in the problem. Without a data structure like a hash set, we must compare each character to every other character.

#### **Algorithm (Brute Force)**
1.  Use two nested loops to iterate through the string.
2.  The outer loop picks a character `c1` at index `i`.
3.  The inner loop iterates through the rest of the string (from `i + 1` onwards), picking a character `c2` at index `j`.
4.  If `c1` is equal to `c2`, a duplicate has been found. Return `false`.
5.  If the loops complete without finding any matches, return `true`.

#### **Code Implementation (Java)**

```java
public class SolutionNoDS {

    /**
     * Checks if a string has all unique characters without using additional data structures.
     * This approach has a worse time complexity but uses constant space.
     */
    public static boolean isUnique(String str) {
        for (int i = 0; i < str.length(); i++) {
            for (int j = i + 1; j < str.length(); j++) {
                if (str.charAt(i) == str.charAt(j)) {
                    return false; // Duplicate found
                }
            }
        }
        return true; // No duplicates found
    }

    public static void main(String[] args) {
        System.out.println("'abcdef' -> " + isUnique("abcdef")); // true
        System.out.println("'hello' -> " + isUnique("hello"));   // false
    }
}
```

#### **Complexity Analysis**
*   **Time Complexity: O(NÂ²)**, due to the nested loops.
*   **Space Complexity: O(1)**, as we are not using any extra storage.

---

### **Solution 3: Optimized "No-DS" Solution (Assuming ASCII)**

The book presents a clever middle-ground solution. While it technically uses an array, it's a fixed-size array, so it's considered O(1) space. This is much faster than the brute-force approach.

#### **Algorithm**
1.  Create a boolean array of size 128, the number of characters in the standard ASCII character set.
2.  Iterate through the string.
3.  For each character, get its ASCII value `val`.
4.  Check the boolean array at index `val`. If `checker[val]` is `true`, we have seen this character before. Return `false`.
5.  If it's `false`, set `checker[val]` to `true` and continue.
6.  If the loop finishes, return `true`.

#### **Code Implementation (Java)**

```java
public class OptimizedSolution {

    /**
     * Checks if a string has all unique characters using a boolean array.
     * This is a very efficient solution if we can assume a fixed character set (like ASCII).
     */
    public static boolean isUnique(String str) {
        // A string longer than the character set size must have duplicates.
        if (str.length() > 128) {
            return false;
        }

        boolean[] checker = new boolean[128]; // Assumes ASCII
        for (int i = 0; i < str.length(); i++) {
            int val = str.charAt(i);
            if (checker[val]) { // Already found this character
                return false;
            }
            checker[val] = true;
        }
        return true;
    }

    public static void main(String[] args) {
        System.out.println("'abcdef' -> " + isUnique("abcdef")); // true
        System.out.println("'hello' -> " + isUnique("hello"));   // false
    }
}
```

#### **Complexity Analysis**
*   **Time Complexity: O(N)**, where N is the length of the string.
*   **Space Complexity: O(1)**, because the boolean array's size is fixed (128) and does not depend on the input string's size.

The book notes that if you know the character set is limited (e.g., only 'a' through 'z'), you can optimize the space even further by using a single integer as a bit vector, similar to the solution for Problem 1.4.