### **Problem 1.2: Check Permutation**

**Problem Statement:** Given two strings, write a method to decide if one is a permutation of the other.

**EXAMPLE**
`Input: "god", "dog"`
`Output: True`

---

### **Explanation: The Core Insight**

The book starts by defining what a permutation is: two strings are permutations of each other if they contain the same characters with the same frequencies. For example, `"apple"` and `"papel"` are permutations.

This leads to a crucial first check:

> If two strings have different lengths, they cannot be permutations.

This simple check can save a lot of work. After this check, there are two primary ways to solve the problem, each with different trade-offs.

---

### **Solution 1: Sort the Strings**

This is a very intuitive and clean approach. If two strings are permutations, then when you sort their characters, the resulting strings will be identical.

#### **Algorithm**
1.  Check if the lengths of the two strings are equal. If not, return `false`.
2.  Convert both strings into character arrays.
3.  Sort both character arrays.
4.  Compare the sorted arrays. If they are identical, the original strings were permutations. Return `true`. Otherwise, return `false`.

#### **Code Implementation (Java)**

```java
import java.util.Arrays;

public class Solution {

    /**
     * Checks if two strings are permutations of each other by sorting them.
     * This is a clean and easy-to-understand solution.
     */
    public static boolean permutation(String s1, String s2) {
        // Step 1: Check lengths. If they are different, they can't be permutations.
        if (s1.length() != s2.length()) {
            return false;
        }

        // Step 2 & 3: Convert to char arrays and sort them.
        char[] s1Array = s1.toCharArray();
        char[] s2Array = s2.toCharArray();
        Arrays.sort(s1Array);
        Arrays.sort(s2Array);

        // Step 4: Compare the sorted arrays.
        return Arrays.equals(s1Array, s2Array);
    }

    public static void main(String[] args) {
        System.out.println("'god', 'dog' -> " + permutation("god", "dog")); // true
        System.out.println("'apple', 'papel' -> " + permutation("apple", "papel")); // true
        System.out.println("'apple', 'apples' -> " + permutation("apple", "apples")); // false
    }
}
```

#### **Complexity Analysis**
*   **Time Complexity: O(N log N)**, where N is the length of the strings. The dominant operation is sorting the character arrays.
*   **Space Complexity: O(N)** or **O(log N)**. It depends on the sorting implementation. If you create new character arrays, it's O(N). If the sort is done in-place, the space is typically O(log N) for the recursion stack in many sorting algorithms.

---

### **Solution 2: Check Character Counts**

This approach is more efficient in terms of time complexity. It leverages the fact that permutations must have identical character counts.

#### **Algorithm**
1.  Check if the lengths of the two strings are equal. If not, return `false`.
2.  Create an integer array to act as a frequency counter for characters (assuming ASCII, so an array of size 128 is sufficient).
3.  Iterate through the first string, incrementing the count for each character in the frequency array.
4.  Iterate through the second string, decrementing the count for each character.
5.  If at any point you try to decrement a count that is already zero (meaning the character doesn't exist in the first string), you can immediately return `false`.
6.  If the loop finishes, it means all characters matched. Return `true`.

#### **Code Implementation (Java)**

```java
public class OptimizedSolution {

    /**
     * Checks if two strings are permutations of each other by counting characters.
     * This is the more time-efficient solution.
     */
    public static boolean permutation(String s1, String s2) {
        // Step 1: Check lengths.
        if (s1.length() != s2.length()) {
            return false;
        }

        // Step 2: Create a frequency counter array. Assumes ASCII character set.
        int[] count = new int[128];

        // Step 3: Count characters in the first string.
        for (int i = 0; i < s1.length(); i++) {
            count[s1.charAt(i)]++;
        }

        // Step 4 & 5: Decrement counts with the second string.
        for (int i = 0; i < s2.length(); i++) {
            int val = s2.charAt(i);
            count[val]--;
            // If a count goes below zero, s2 has a character not in s1 or has more of it.
            if (count[val] < 0) {
                return false;
            }
        }

        // Step 6: If we get here, all counts are zero.
        return true;
    }

    public static void main(String[] args) {
        System.out.println("'god', 'dog' -> " + permutation("god", "dog")); // true
        System.out.println("'apple', 'papel' -> " + permutation("apple", "papel")); // true
        System.out.println("'apple', 'apples' -> " + permutation("apple", "apples")); // false
    }
}
```

#### **Complexity Analysis**
*   **Time Complexity: O(N)**, where N is the length of the strings. We iterate through each string once.
*   **Space Complexity: O(1)**. The frequency array is a fixed size (128), which is constant and does not depend on the input string size.

### **Which Solution to Use?**

The book notes that the **character count solution (Solution 2) is more efficient**. However, the **sorting solution (Solution 1)** is often easier to write and understand, and it might be preferable if you are not allowed to use additional data structures, as some sorting algorithms can be done in-place.