### **Problem 1.3: URLify**

**Problem Statement:** Write a method to replace all spaces in a string with `%20`. You may assume that the string has sufficient space at the end to hold the additional characters, and that you are given the "true" length of the string. (Note: If implementing in Java, please use a character array so that you can perform this operation in-place.)

**EXAMPLE**
`Input: "Mr John Smith    ", length: 13`
`Output: "Mr%20John%20Smith"`

---

### **Explanation: The Core Insight**

The most critical part of this problem is the **in-place** constraint. If you were allowed to create a new string, the solution would be simple. However, modifying the string in-place requires careful thought.

The book points out the inefficiency of a forward-moving approach. If you iterate from the beginning and replace a space with `%20`, you must shift every subsequent character three places to the right. Doing this repeatedly would lead to an O(NÂ²) time complexity.

The key insight is to **work backwards**. Since we have a buffer of empty spaces at the end of the string, we can avoid the costly shifting. We can use a two-pointer approach:
1.  One pointer (`i`) starts at the end of the "true" string.
2.  The other pointer (`j`) starts at the very end of the character array buffer.

By moving from back to front, we know that we will never overwrite a character we haven't processed yet. This allows us to build the new string in O(N) time.

---

### **Solution: The Two-Pointer Algorithm**

This is the optimal, in-place solution presented in the book.

#### **Algorithm**
1.  **Count Spaces:** First, iterate through the "true" length of the string and count the number of spaces.
2.  **Calculate New Length:** The new length of the string will be `trueLength + (numberOfSpaces * 2)`. (Each space is replaced by three characters `%20`, which is a net gain of two characters).
3.  **Initialize Pointers:** Set up two pointers (or indices). `i` will start at `trueLength - 1` (the last character of the original string). `j` will start at `newLength - 1` (the last slot of the buffer).
4.  **Iterate Backwards:** Loop while `i` is greater than or equal to 0.
    *   If the character at `str[i]` is a space, copy the characters `%`, `2`, `0` into `str[j]`, `str[j-1]`, and `str[j-2]` respectively. Decrement `j` by 3.
    *   If the character at `str[i]` is not a space, copy it to `str[j]`. Decrement `j` by 1.
    *   In both cases, decrement `i` by 1.
5.  The loop will finish when all characters from the original string have been processed, and the new string will be fully formed.

#### **Code Implementation (Java)**

```java
public class URLify {

    /**
     * Replaces all spaces in a string with '%20' in-place.
     * This is the optimal two-pointer solution from the book.
     *
     * @param str The character array to modify. It must have enough space at the end.
     * @param trueLength The "true" length of the string, excluding the extra buffer space.
     */
    public static void replaceSpaces(char[] str, int trueLength) {
        // Step 1: Count the number of spaces within the true length.
        int spaceCount = 0;
        for (int i = 0; i < trueLength; i++) {
            if (str[i] == ' ') {
                spaceCount++;
            }
        }

        // Step 2: Calculate the index where the new string will end.
        int index = trueLength + spaceCount * 2;
        // If the buffer is larger than needed, just ensure we don't go out of bounds.
        // This handles cases where the input buffer might be even larger than required.
        if (index > str.length) {
            // This case shouldn't happen with the problem's guarantees, but it's good practice.
            return;
        }

        // Step 3: Initialize two pointers.
        // i is the pointer for the end of the original string.
        // index is the pointer for the end of the new string.
        int i = trueLength - 1;

        // Step 4: Iterate backwards, editing the string.
        for (; i >= 0; i--) {
            if (str[i] == ' ') {
                // Replace space with %20
                str[index - 1] = '0';
                str[index - 2] = '2';
                str[index - 3] = '%';
                index -= 3;
            } else {
                // Move character to the end
                str[index - 1] = str[i];
                index--;
            }
        }
    }

    public static void main(String[] args) {
        String input = "Mr John Smith    ";
        char[] str = input.toCharArray();
        int trueLength = 13;

        System.out.println("Original: \"" + new String(str) + "\"");
        replaceSpaces(str, trueLength);
        System.out.println("URLified: \"" + new String(str) + "\""); // Expected: "Mr%20John%20Smith"
    }
}
```

#### **Complexity Analysis**
*   **Time Complexity: O(N)**, where N is the true length of the string. We iterate through the string a constant number of times (once to count spaces, once to edit), which is linear.
*   **Space Complexity: O(1)**. The operation is performed in-place. We only use a few extra variables for counting and indexing, which requires constant space.